## Last Updated on 01/29/2019

#######################################
######### Author credentials ##########
#######################################
## Axel Fischer                      ##
## MPI of Molecular Plant Physiology ##
## Bioinformatics AG Walther         ##
## Am Muehlenberg 1                  ##
## 14476 Potsdam                     ##
## Fon: +49 331 5678615              ##
## Fax: +49 331 5678999              ##
## Email: afischer@mpimp-golm.mpg.de ##
#######################################
usage_and_exit <- function(x) {
    if(x==0) {
        cat(greyish("==================================================================================\n"))
        cat(greyish("This R script can run in",length(script.modes.V),"different modes:\n"))
        cat(greyish("==================================================================================\n"))
        sapply(c(1:length(script.modes.V)),function(x){
            script.mode <- script.modes.V[x]
            cat(greeny("(",x,")",script.mode),greyish("\n==================================================================================\n"))
        })
    } else {
        cat(greyish("
===============================================================================
Parameters:
===============================================================================
"))
    }
    if(x==1) {
        cat(greyish("
(1) Script mode is 'generateGraph'\n
(2) Absolute path to the working directory were all data from the ISEIS.sh pipeline are generated and saved to.\n
(3) Blast results file generated within Section 2 of the ISEIS.sh pipeline\n
(4) Prefix of files which were generated by the ISEIS.sh shell script (regular expression: <Param2>_illumina-ON-<Param1>\n
(5) Minimal alignment length within the blast result\n
(6) Prefix for the output file\n
(7) Suffix for the output file\n
(8) Minimal coverage cut off. Anything else is filtered out!\n
(9) Comma seperated list of integer-identifiers. If you want to exclude for example contig 'IDBA_12', you should put in here '12'\n
(10) Comma seperated list of pairs (within pairs identifiers are seperated by '_') which define edges between vertices. If you want to remove two particular edges between '16e' and '155s' as well as between '12e' and '234e' than put in '16e_155s,12e_234e'\n
(11) Number plots that will be generated\n
(12) Cex factor for adjusting font size used for creating the PDF file(s)\n
===============================================================================\n"),
greeny("Example: Rscript SAGBAC.R generateGraph /home/mustermann/MyAssemblyDirectory MyAssembler.fa.blastout.cutted.tsv mySample_illumina-ON-myAssembler 49 mySample noChanges 0 \"\" \"\" 1 1.1\n"),
greyish("===============================================================================\n")
)
    }
    if(x==2) {
        cat(greyish("
(1) Script mode is 'reorderBlastOutput'\n
(2) Absolute path to the working directory were all data from the ISEIS.sh pipeline are generated and saved to.\n
(3) Output file of the previous ISEIS.R run generated a file with the prefix 'Blastdata4MastercirclePath_<sample name>_'\n
(4) File which contains just one row with the order of appearance of contig names \n
(5) Prefix of files which were generated by the ISEIS.sh shell script (regular expression: <Param2>_illumina-ON-<Param1>\n
(6) Prefix for the output file\n
(7) Suffix for the output file\n
===============================================================================\n"),
greeny("Example: Rscript SAGBAC.R reorderBlastOutput /home/mustermann/MyAssemblyDirectory Blastdata4MastercirclePath_mySample_20200124_noChanges.txt myContigNewOrderFile mySample_illumina-ON-myAssembler myPrefix mySuffix\n"),
greyish("===============================================================================\n")
)    }
    if(x==3) {
        cat(greyish("
(1) Script mode is 'generateMasterCircle'\n
(2) Absolute path to the working directory were all data from the ISEIS.sh pipeline are generated and saved to.\n
(3) Output file of a previous ISEIS.R run mainly generated using the 'reorderBlastOutput' having the prefix 'Reordered_Blastdata4MastercirclePath_<sample name>_'\n
(4) Original fasta file from the de-novo assembly used for the 'against itself' blast run.\n
(5) File name of your newly generated master circle fasta sequence. Example: MasterCircle.fasta or MasterCircle.fa\n
(6) Fasta header information (without '>'). Attention: If spaces are necessary put the fasta header string into single or double quotes\n
===============================================================================\n"),
greeny("Example: Rscript SAGBAC.R generateMasterCircle Reordered_Blastdata4MastercirclePath_mySample_20200124_noChanges.txt myAssembly.fa myMasterCircle.fasta \"Mitochondria [My Organism]\"\n"),
greyish("5===============================================================================\n")
)
    }
    if(x==4) {
        cat(greyish("
(1) Script mode is 'calculateSubcircles'\n
(2) Absolute path to the working directory were all data from the ISEIS.sh pipeline are generated and saved to.\n
(3) Available graphML XML file within the absolute path\n
(4) Colon seperated list of numeric identifier of contigs which are recombinogenic repeat pairs\n
(5) Number of times RRPs can be traversed\n
(6) PDF output file name\n
Example: Rscript SAGBAC.R calculateSubcircles /home/mustermann/MyAssemblyDirectory graphML_Bert_20210831_RemoveSmallContigs.xml '121,443,518,539,773,795' 2 test.pdf
===============================================================================
"))
    }
    if(x==5) {
        cat(greyish("
(1) Script mode is 'getAllPairCounts'\n"),
greeny("Example: Rscript SAGBAC.R getAllPairCount UEBERARBEITEN\n"),
greyish("===============================================================================\n")
)
    }
    if(x==6) {
        cat(greyish("
(1) Script mode is 'getSomePairCounts'\n
(2) Absolute path to the working directory were all data from the ISEIS.sh pipeline are generated and saved to.\n
(3) Prefix of files which were generated by the ISEIS.sh shell script (regular expression: <Param2>_illumina-ON-<Param1>\n
(4) Colon seperated list of integer-based comma-delimited key value pairs:\n\n    Example 1,2:5,6;9,10:15,16\n
    Counts will be extracted for the following pairs if present:\n    1 vs 5  | 1 vs 6  | 2  vs 5  | 2  vs 6\n    ----------------------------------------\n     9 vs 15 | 9 vs 16 | 10 vs 15 | 10 vs 16\n
===============================================================================\n"),
greeny("Example: Rscript SAGBAC.R getOtherPairCount /home/mustermann/MyAssemblyDirectory mySample_illumina-ON-myAssembler \"1,2:5,6;9,10:15,16\"\n"),
greyish("4===============================================================================\n")
,"")
    }
##     if(x==5) {
##         cat(greyish("
## ===============================================================================
## Parameters:
## ===============================================================================

## ===============================================================================
## "))
##     }

}
##############################################
### Check for necessary packages
needed.packages <- c("igraph","crayon")
install.selection <- ! needed.packages %in% installed.packages()

for (package in needed.packages[install.selection]) {
    cat(package," library isn't installed in your R version. It will be now installed:\n")
    install.packages(package,quiet = TRUE)
}
for (package in needed.packages) {
    library(package,quietly = TRUE,character.only = TRUE,warn.conflicts = FALSE)
}
stoppy <- red $ bold
greeny <- green
greyish <- blurred
##############################################
### Required functions
extract.Substr.Over.Regexp <- function(x,pattern) {
    regexped <- regexpr(pattern,x)
    regexp.starts <- as.vector(unlist(regexped))
    regexp.ends <- regexp.starts+attr(regexped,"match.length")-1
    processed <- substr(x,regexp.starts,regexp.ends)
    return(processed[regexp.starts!=-1])
}

verticesTable4adjlist <- function(eV) {
    eV <- paste(rep(eV,each=2),c("s","e"),sep="")
    eV <- eV[order(eV)]
    eN <- c(1:length(eV))
    eG <- rep(c(1:(length(eV)/2)),each=2)
    return(data.frame(endings=eV,numbering=eN,groups=eG,stringsAsFactors = FALSE))
}

endings2graph <- function(e.dF,M.dF) {
    colnames(e.dF)[1] <-  "endings"
    e.m.dF <- merge(e.dF,M.dF[,c(1:2)],sort=FALSE)
    colnames(e.m.dF)[1] <- "q.endings"
    colnames(e.m.dF)[3] <- "q.numbering"
    colnames(e.m.dF)[2] <- "endings"
    e.m.dF <- merge(e.m.dF,M.dF[,c(1:2)],sort=FALSE)
    colnames(e.m.dF)[1] <- "h.endings"
    colnames(e.m.dF)[4] <- "h.numbering"
    e.m.dF <- e.m.dF[,c(3,4)]
    permn.L <- list()
    for (i in c(1:length(M.dF$numbering))) {
        if(i%%2==0) permn.L[[i]] <- M.dF$numbering[i-1]
        if(i%%2==1) permn.L[[i]] <- M.dF$numbering[i+1]
    }
    for (i in c(1:length(e.m.dF[,1]))) {
        permn.L[[e.m.dF[i,1]]] <- c(permn.L[[e.m.dF[i,1]]],e.m.dF[i,2])
    }
    for (i in c(1:length(permn.L))) {
        permn.L[[i]] <- unique(permn.L[[i]])
    }
    check.V <- c()
    edgeColors <- c()
    for (i in c(1:length(permn.L))) {
        for (j in c(1:length(permn.L[[i]]))) {
            comb1 <- paste(i,permn.L[[i]][j],sep="_")
            comb2 <- paste(permn.L[[i]][j],i,sep="_")
            if (comb1 %in% check.V | comb2 %in% check.V) {
                                        #      cat("Next\n")
                next;
            } else {
                if (j==1) edgeColors <- c(edgeColors,"red")
                if (j!=1) edgeColors <- c(edgeColors,"gray")
                check.V <- c(check.V,paste(i,permn.L[[i]][j],sep="_"))
            }
        }
    }
    g <- graph.adjlist(permn.L,mode="all",duplicate=TRUE)
    unlinked.V <- as.integer(gsub("[es]","",M.dF[sapply(permn.L,length)==1,1]))
    E(g)$color <- "gray"
    if (length(E(g)$color)==length(edgeColors)) {
        E(g)$color <- edgeColors
    }else {
        cat("edgeColors and count of edges are not the same\nColors are unchanged\n")
    }
    return(list(g,unlinked.V,permn.L))
}

convertToComplement<-function(x){
    bases=c("A","C","G","T")
    xx<-unlist(strsplit(toupper(x),NULL))
    paste(unlist(lapply(xx,function(bbb){
        if(bbb=="A") compString<-"T"
        if(bbb=="C") compString<-"G"
        if(bbb=="G") compString<-"C"
        if(bbb=="T") compString<-"A"
        if(!bbb %in% bases) compString<-"N"
        return(compString)
    })),collapse="")
}

strReverse <- function(x) sapply(lapply(strsplit(x, NULL), rev), paste, collapse="")

##############################################
###### Load and check command arguments ######
script.modes.V <- c("generateGraph","reorderBlastOutput","generateMasterCircle","calculateSubcircles")#,"getAllPairCounts","getSomePairCounts")
if(length(commandArgs(TRUE))==0) {
    stop(paste(stoppy("No script mode was recognized.\n"),usage_and_exit(0),sep="\n"))
}
script.mode <- commandArgs(TRUE)[1]
if (length(commandArgs(TRUE))==1 & !script.mode %in% script.modes.V) {
    usage_and_exit(0)
    stop(stoppy("Specified script mode is not known"))
}

if(script.mode=="generateGraph" & length(commandArgs(TRUE))!=12) {
    usage_and_exit(1)
    stop(stoppy("Insufficient number of command arguments.\n"))
} else if (script.mode=="reorderBlastOutput" & length(commandArgs(TRUE))!=5) {
    usage_and_exit(2)
    stop(stoppy("Insufficient number of command arguments.\n"))
} else if (script.mode=="generateMasterCircle" & length(commandArgs(TRUE))!=6) {
    usage_and_exit(3)
    stop(stoppy("Insufficient number of command arguments.\n"))
} else if (script.mode=="calculateSubcircles" & length(commandArgs(TRUE))!=6) {
    usage_and_exit(4)
    stop(stoppy("Insufficient number of command arguments.\n"))
## } else if (script.mode=="getAllPairCounts" & length(commandArgs(TRUE))!=4) {
##     usage_and_exit(5)
##     stop(stoppy("Insufficient number of command arguments.\n"))
## } else if (script.mode=="getSomePairCounts" & length(commandArgs(TRUE))!=4) {
##     usage_and_exit(6)
##     stop(stoppy("Insufficient number of command arguments.\n"))
} else if(script.mode=="generateGraph") {
    wd <- commandArgs(TRUE)[2]
    if (!dir.exists(wd)) {
        stop(paste("Provided working directory '",wd,"' does not exists and so no fasta files in it. Please check.\n",sep=""))
    } else {
        setwd(wd)
    }
    blast.file <- commandArgs(TRUE)[3]
    sagbac.prefix <- commandArgs(TRUE)[4]
    ## mainContigs.file <- commandArgs(TRUE)[4]
    ## idxstats.file <- commandArgs(TRUE)[5]
    ## pairCounts.file <- commandArgs(TRUE)[14]
    mainContigs.file <- paste(sagbac.prefix,".srt.bam.idxstats.trustedContigs.txt",sep = "")
    idxstats.file <- paste(sagbac.prefix,".srt.bam.idxstats.ratios.txt",sep = "")
    pairCounts.file <- paste(sagbac.prefix,".bam.mates.MappedOnDiffContig.pairCounts",sep = "")
    for (inputfile in c(blast.file,mainContigs.file,idxstats.file)) {
        if (!file.exists(inputfile)) {stop(paste("Provided input file '",inputfile,"' does not exists. Please check.\n",sep=""))}
    }
    alignlen.cutoff <- as.integer(commandArgs(TRUE)[5])
    out.prefix <- commandArgs(TRUE)[6]
    out.suffix <- commandArgs(TRUE)[7]
    cov.cutoff <- as.integer(commandArgs(TRUE)[8])
    manual.excludedContigs.byUser <- commandArgs(TRUE)[9]
    manual.excludedEdges.byUser <- commandArgs(TRUE)[10]
    plot.number <- as.integer(commandArgs(TRUE)[11])
    font.size <- as.numeric(commandArgs(TRUE)[12])

############################################################################
## For Manual curation, please start here at that point to load things in ##
############################################################################
## Un-comment all rows until the section ends                             ##
############################################################################
    ## library("igraph")
    ## wd <- "/Users/Axel/Package4Workshop/bert_output/"
    ## setwd(wd)
    ## blast.file <- "Bert.fa.blastout.cutted.tsv"
    ## sagbac.prefix <- ""
    ## mainContigs.file <- paste(sagbac.prefix,".srt.bam.idxstats.trustedContigs.txt",sep = "")
    ## idxstats.file <- paste(sagbac.prefix,".srt.bam.idxstats.ratios.txt",sep = "")
    ## pairCounts.file <- paste(sagbac.prefix,".bam.mates.MappedOnDiffContig.pairCounts",sep = "")
    ## alignlen.cutoff <- 49
    ## cov.cutoff <- 3000
    ## out.prefix <- "bert"
    ## out.suffix <- "withinRscript1"
    ## plot.number <- 1
    ## manual.excludedContigs.byUser <- ""
    ## manual.excludedEdges.byUser <- ""
############################################################################
## Section end                                                            ##
############################################################################

##################################
## Load blastAgainstItself file ##
##################################
    blast.colClasses <- c("character","integer","character","integer",rep("numeric",2),rep("integer",10))
    cat(paste("Load Blast file:",blast.file,sep=" "),"\n")
    blastALL.dF <- read.table(paste(wd,blast.file,sep=""),header=FALSE,as.is=TRUE,sep=";",colClasses = blast.colClasses)
    colnames(blastALL.dF) <- c("qchr","qlen","hchr","hlen","score","evalue","qstart","qend","hstart","hend","qstrand","hstrand","ident","pos","gaps","alignlen")
    cat("Internal processing started...\n")
    ## Apply alignment length filter
    blastALL.dF <- blastALL.dF[blastALL.dF$alignlen>alignlen.cutoff,]
    ## Extract numeric values of contig names
    blastALL.dF$qchrnum <- as.integer(extract.Substr.Over.Regexp(blastALL.dF$qchr,"[0-9]+"))
    blastALL.dF$hchrnum <- as.integer(extract.Substr.Over.Regexp(blastALL.dF$hchr,"[0-9]+"))
    ## Resort qstart and qend by min and max respectively
    q.min <- apply(blastALL.dF[,c(7,8)],1,min)
    q.max <- apply(blastALL.dF[,c(7,8)],1,max)
    blastALL.dF$qstart <- q.min
    blastALL.dF$qend <- q.max

#########################
## Define main contigs ##
#########################
    mainContigs.V <- as.integer(extract.Substr.Over.Regexp(read.table(paste(wd,mainContigs.file,sep=""),header=FALSE,as.is=TRUE,sep="\t")[,1],"[0-9]+"))
    ## Define hits on main contigs ONLY
    main.sel <- blastALL.dF$hchrnum %in% mainContigs.V & blastALL.dF$qchrnum %in% mainContigs.V
    ## Define hits NOT on main contigs ONLY
    non.main.sel <- !blastALL.dF$hchrnum %in% mainContigs.V & !blastALL.dF$qchrnum %in% mainContigs.V
    ## Define hits hchr == main contig BUT NOT qchr
    sel <- blastALL.dF$hchrnum %in% mainContigs.V & !blastALL.dF$qchrnum %in% mainContigs.V
    ## Reverse definition of sel
    anti.sel <- !blastALL.dF$hchrnum %in% mainContigs.V & blastALL.dF$qchrnum %in% mainContigs.V
    ## Define hits between different contigs
    diff.contig.sel <- blastALL.dF$qchrnum != blastALL.dF$hchrnum

##########################
##### NEW DEFINITION #####
##########################
    q.starts.sel <- apply(blastALL.dF[,c("qstart","qend","alignlen")],1,function(x) x[1]==1 && x[1]+x[2]-1==x[3])
    q.ends.sel <- apply(blastALL.dF[,c("qstart","qend","alignlen","qlen")],1,function(x) x[2]==x[4] && x[1]==x[4]-x[3]+1)
    q.both.sel <- q.starts.sel & q.ends.sel
    h.starts.sel <- apply(blastALL.dF[,c("hstart","hend","alignlen")],1,function(x) x[1]==1 && x[1]+x[2]-1==x[3])
    h.ends.sel <- apply(blastALL.dF[,c("hstart","hend","alignlen","hlen")],1,function(x) x[2]==x[4] && x[1]==x[4]-x[3]+1)
    h.both.sel <- h.starts.sel & h.ends.sel
    endings.sel <- (q.starts.sel|q.ends.sel) & (h.starts.sel|h.ends.sel)
    main.2.diff.main.sel <- main.sel & blastALL.dF$qchrnum!=blastALL.dF$hchrnum & blastALL.dF$qchrnum %in% mainContigs.V & blastALL.dF$hchrnum %in% mainContigs.V & endings.sel

###########################
## Introduce ending tags ##
###########################
    dF.len <- length(blastALL.dF[,1])
    blastALL.dF$qchrtag <-  rep("Q",dF.len)
    blastALL.dF$hchrtag <-  rep("H",dF.len)
    blastALL.dF$qchrtag[q.starts.sel] <-  "s"
    blastALL.dF$qchrtag[q.ends.sel] <-  "e"
    blastALL.dF$qchrtag[q.both.sel] <-  "b"
    blastALL.dF$hchrtag[h.starts.sel] <-  "s"
    blastALL.dF$hchrtag[h.ends.sel] <-  "e"
    blastALL.dF$hchrtag[h.both.sel] <-  "b"

    same.MC.diff.endings.sel <- main.sel & blastALL.dF$qchrnum==blastALL.dF$hchrnum & blastALL.dF$qchrtag!=blastALL.dF$hchrtag & (blastALL.dF$qchrtag=="s" | blastALL.dF$qchrtag=="e") & (blastALL.dF$hchrtag=="s" | blastALL.dF$hchrtag=="e")

                                        # Create ending tags by merge chrnum and chrtag together
    blastALL.dF$q.endings <- apply(cbind(blastALL.dF$qchrnum,blastALL.dF$qchrtag),1,function(x) paste(x,collapse=""))
    blastALL.dF$h.endings <- apply(cbind(blastALL.dF$hchrnum,blastALL.dF$hchrtag),1,function(x) paste(x,collapse=""))

####################################################
    ## BlastAll.dF construction is finished           ##
    ## At this point you can investigate blastAll.dF  ##
####################################################
    ## blastALL.dF[blastALL.dF$q.endings=="121s" & blastALL.dF$h.endings=="16e",]
    ## sapply(colnames(blastALL.dF),cat,"\n")
####################################################


###################################
##  Determine level information  ##
###################################
    if (manual.excludedContigs.byUser=="") {
        manual.excluded <- c()
    } else {
        manual.excluded <- strsplit(manual.excludedContigs.byUser,",")[[1]]
        cat("Excluded contigs: ",paste(manual.excluded,collapse = ", "),"\n")
    }
    idxstats.dF <- read.table(paste(wd,idxstats.file,sep=""),header = FALSE,as.is = TRUE,sep="\t")[,c(1,5)]
    colnames(idxstats.dF) <- c("contig","coverage")
    includedContigs.byCoverage.V <- idxstats.dF$contig[idxstats.dF$coverage >= cov.cutoff]

    level.L <- list()
    ## manual.excluded <- c(76,3)
    collapsed.chrtags <- apply(blastALL.dF[,c("qstrand","hstrand")],1,function(x) paste(x,collapse="|"))
    collapsed.endings <- apply(blastALL.dF[,c("qchrtag","hchrtag")],1,function(x) paste(x,collapse="|"))
    blastALL.dF$collapsed.chrtags.endings <- apply(cbind(collapsed.chrtags,collapsed.endings),1,function(x) paste(x,collapse=","))
    posneg.sel <- blastALL.dF$collapsed.chrtags.endings=="1|-1,e|e" | blastALL.dF$collapsed.chrtags.endings=="1|-1,s|s"
    pospos.sel <- blastALL.dF$collapsed.chrtags.endings=="1|1,e|s" | blastALL.dF$collapsed.chrtags.endings=="1|1,s|e"
    ## ylike.sel <- blastALL.dF$collapsed.chrtags.endings=="1|1,e|e" | blastALL.dF$collapsed.chrtags.endings=="1|1,s|s"
    chrtags.endings.sel <- posneg.sel | pospos.sel # | both.sel
    manual.excluded.sel <- !blastALL.dF$qchrnum %in% manual.excluded & !blastALL.dF$hchrnum %in% manual.excluded
    iterate.bool <- endings.sel & blastALL.dF$alignlen >= alignlen.cutoff & blastALL.dF$q.endings != blastALL.dF$h.endings & manual.excluded.sel & chrtags.endings.sel & blastALL.dF$qchr %in% includedContigs.byCoverage.V & blastALL.dF$hchr %in% includedContigs.byCoverage.V
    sum.chrnum.set <- mainContigs.V[!mainContigs.V %in% manual.excluded]
    mainContigs.V <- mainContigs.V[!mainContigs.V %in% manual.excluded]
    sum.ending.set  <- paste(rep(unique(blastALL.dF$qchrnum[endings.sel & blastALL.dF$qchrnum %in% mainContigs.V]),each=2),c("s","e"),sep="")
    i <- 1
    new.endings <- 1

#########################
## Network lookup loop ##
#########################
    cat("Breath First search (BFS) started...\n")
    while(length(new.endings) !=0) {
        new.dF <- blastALL.dF[iterate.bool & blastALL.dF$qchrnum %in% sum.chrnum.set,]
        if (i!=1) {
            last.new.endings <- new.endings
            last.new.chrnums <- new.chrnums
        }
        new.endings <- new.dF$h.endings[!new.dF$h.endings %in% sum.ending.set]
        old.endings <- new.dF$h.endings[new.dF$h.endings %in% sum.ending.set]
        new.chrnums <- new.dF$hchrnum[!new.dF$hchrnum %in% sum.chrnum.set]
        old.chrnums <- new.dF$hchrnum[new.dF$hchrnum %in% sum.chrnum.set]
        new.dF$level <- rep(i,length(new.dF[,1]))
        level.L[[i]] <- new.dF
        i <- i +1
        iterate.bool[iterate.bool & blastALL.dF$q.endings %in% sum.ending.set] <- FALSE
        sum.ending.set <- unique(c(sum.ending.set,new.endings))
        sum.chrnum.set <- unique(c(sum.chrnum.set,new.chrnums))
    }
    cat("BFS ended\n")

########################
## iGraph preparation ##
########################
    alllevel.endings.dF <- do.call(rbind,level.L)

    if (manual.excludedEdges.byUser=="") {
        manual.excluded.pairs.L <- list()
    } else {
        manual.excluded.pairs.L <- strsplit(strsplit(manual.excludedEdges.byUser,",")[[1]],"_")
        cat("Excluded edges:\t")
        cat(paste(sapply(manual.excluded.pairs.L,function(x)paste(x,collapse = "--")),collapse =", "))
        cat("\n")
    }
    ## manual.excluded.pairs.L <- strsplit(strsplit("518s_5s,762e_795e",",")[[1]],"_")

    for (pair in manual.excluded.pairs.L) {
        left <- pair[1]
        right <- pair[2]
        sel <- !((alllevel.endings.dF$q.endings==left & alllevel.endings.dF$h.endings==right) | (alllevel.endings.dF$q.endings==right & alllevel.endings.dF$h.endings==left))
        alllevel.endings.dF <- alllevel.endings.dF[sel,]
    }

    alllevel.endings.dF.1 <- alllevel.endings.dF[,c("qchrnum","hchrnum","q.endings","h.endings")]
    alllevel.endings.dF.2 <- alllevel.endings.dF[,c("hchrnum","qchrnum","h.endings","q.endings")]
    colnames(alllevel.endings.dF.2) <-  colnames(alllevel.endings.dF.1)
    alllevel.endings.allCombs.dF <- unique(rbind(alllevel.endings.dF.1,alllevel.endings.dF.2))
    alllevel.endings.allCombs.dF <- alllevel.endings.allCombs.dF[order(alllevel.endings.allCombs.dF$qchrnum),]
    ale.V <- unique(c(mainContigs.V,as.vector(unlist(alllevel.endings.allCombs.dF[,c("qchrnum","hchrnum")]))))

    ale.dF <- verticesTable4adjlist(ale.V)
    result.L <- endings2graph(alllevel.endings.allCombs.dF[,c("h.endings","q.endings")],ale.dF)
    ale.graph <- result.L[[1]]
    unlinked.V <- as.integer(result.L[[2]])

    ## ale.dF[sapply(result.L[[3]],length)==1,1]

    if(length(unlinked.V!=0)) {
        cat("Unlinked contigs saved under: Processed_Blastoutput_for_unlinked_contigs4manualCuration.csv\n")
        write.table(blastALL.dF[blastALL.dF$qchrnum %in% unlinked.V & blastALL.dF$hchrnum %in% unlinked.V & blastALL.dF$qchrnum != blastALL.dF$hchrnum,],"Processed_Blastoutput_for_unlinked_contigs4manualCuration.csv",quote = FALSE,col.names = TRUE,row.names = FALSE,sep = "\t")
    }

    contigs.in.graph.file <- paste("Contigs_in_graph_",out.prefix,"_",gsub("-","",Sys.Date()),"_",out.suffix,".txt",sep="")
    cat("Contigs within the graph saved under:",contigs.in.graph.file,"\n")
    write.table(paste("IDBA_",ale.V,sep=""),contigs.in.graph.file,quote = FALSE,col.names = FALSE,row.names = FALSE,sep="\t")

    idxstats4GraphContigs <- paste("idxstats4GraphContigs_",out.prefix,"_",gsub("-","",Sys.Date()),"_",out.suffix,".txt",sep = "")
    write.table(idxstats.dF[idxstats.dF$contig %in% unique(alllevel.endings.dF$qchr),],idxstats4GraphContigs,quote = FALSE,col.names = FALSE,row.names = FALSE,sep="\t")

    pairCounts.dF <- read.table(pairCounts.file,header = FALSE,as.is = TRUE,sep = "\t")
    colnames(pairCounts.dF) <- c("qchrnum","hchrnum","count")

    blastdata4MasterCirclePath.file <- paste("Blastdata4MastercirclePath_",out.prefix,"_",gsub("-","",Sys.Date()),"_",out.suffix,".txt",sep = "")
    data4master.dF <- alllevel.endings.dF[,c("qchr","qstart","qend","qstrand","qlen","qchrtag","hchr","hstart","hend","hstrand","hlen","hchrtag","alignlen","qchrnum","hchrnum")]
    data4master.dF$pairCounts <- rep(0,length(data4master.dF$qchr))
    for (x in c(1:length(data4master.dF$qchrnum))) {
        if (data4master.dF$hchrnum[x] < data4master.dF$qchrnum[x] ) {
            pair.index <- intersect(which(data4master.dF$hchrnum[x]==pairCounts.dF$qchrnum),which(data4master.dF$qchrnum[x]==pairCounts.dF$hchrnum))
##             cat("Swapped","\t")
        } else {
            pair.index <- intersect(which(data4master.dF$hchrnum[x]==pairCounts.dF$hchrnum),which(data4master.dF$qchrnum[x]==pairCounts.dF$qchrnum))
##             cat("Unchanged","\t")
        }
        if(length(pair.index)==0) {
            data4master.dF$pairCounts[x] <- 0
        } else {
            data4master.dF$pairCounts[x] <- pairCounts.dF$count[pair.index]
        }
##        cat(data4master.dF$qchrnum[x],"\t",data4master.dF$hchrnum[x],"\t",pair.index,"\n")        
    }

    write.table(data4master.dF,blastdata4MasterCirclePath.file,quote = FALSE,col.names = TRUE,row.names = FALSE,sep="\t")


#################
## iGraph plot ##
#################
    cat("Plot graphs\n")
    for (i in c(1:plot.number)) {
        pdf(paste(wd,"iGraph_",out.prefix,"_allLevels_CleanedUp_",i,"_",gsub("-","",Sys.Date()),"_",out.suffix,".pdf",sep=""),width=6,height=6)
        par(mar=c(1,1,1,1),cex=font.size)
        plot.igraph(ale.graph,edge.width=3,vertex.label=ale.dF$endings,vertex.size=0)
        cat(ale.dF$endings,"\n")
        dev.off()
    }
    cat("Save graph as graphML in xml format\n")
    graphml.file <- paste("graphML_",out.prefix,"_",gsub("-","",Sys.Date()),"_",out.suffix,".xml",sep="")
    graph4saving <- set.vertex.attribute(ale.graph, "name", value=ale.dF$endings)
    write.graph(graph4saving,graphml.file,format="gml")
} else if (script.mode == "reorderBlastOutput") {
    wd <- commandArgs(TRUE)[2]
    if (!dir.exists(wd)) {
        stop(paste("Provided working directory '",wd,"' does not exists and so no fasta files in it. Please check.\n",sep=""))
    } else {
        setwd(wd)
    }
    blast.file <- commandArgs(TRUE)[3]
    new.contig.order.file <- commandArgs(TRUE)[4]
    sagbac.prefix <- commandArgs(TRUE)[5]
    for (inputfile in c(blast.file,new.contig.order.file)) {
        if (!file.exists(inputfile)) {stop(paste("Provided input file '",inputfile,"' does not exists. Please check.\n",sep=""))}
    }   
    data4master.dF <- unique(read.table(blast.file,header = TRUE,as.is = TRUE,sep = "\t"))
    ordered.contigs.names.V <- read.table(new.contig.order.file,header = FALSE,as.is = TRUE,sep = "\t")[,1]
    ## str(ordered.contigs.names.V)
    indeces.reordered.contig.names.V <- c()
    for (i in c(1:(length(ordered.contigs.names.V)-1))){
        left <- ordered.contigs.names.V[i]
        right <- ordered.contigs.names.V[i+1]
##        cat(left,right,"\n")
        indeces.reordered.contig.names.V <- c(indeces.reordered.contig.names.V,which(data4master.dF$qchr==left & data4master.dF$hchr==right))
    }
    left <- ordered.contigs.names.V[length(ordered.contigs.names.V)]
    right <- ordered.contigs.names.V[1]
    indeces.reordered.contig.names.V <- c(indeces.reordered.contig.names.V,which(data4master.dF$qchr==left & data4master.dF$hchr==right))
    write.table(data4master.dF[indeces.reordered.contig.names.V,],paste("Reordered",blast.file,sep = "_"),quote = FALSE,col.names = TRUE,row.names = FALSE,sep = "\t")
    cat("Reordering finished: You find your reordered blast outcome in the file:",paste("Reordered",blast.file,sep = "_"),"\n")
} else if (script.mode == "generateMasterCircle") {
    wd <- commandArgs(TRUE)[2]
    if (!dir.exists(wd)) {
        stop(paste("Provided working directory '",wd,"' does not exists and so no fasta files in it. Please check.\n",sep=""))
    } else {
        setwd(wd)
    }
    blast.file <- commandArgs(TRUE)[3]
    in.fasta.file <- commandArgs(TRUE)[4]
    out.fasta.file <- commandArgs(TRUE)[5]
    fasta.header <- commandArgs(TRUE)[6]
    for (inputfile in c(blast.file,in.fasta.file)) {
        if (!file.exists(inputfile)) {stop(paste("Provided input file '",inputfile,"' does not exists. Please check.\n",sep=""))}
    }   
    data4master.dF <- read.table(blast.file,header = TRUE,as.is = TRUE,sep = "\t")[,c(1:13)]
    ## cat(dim(data4master.dF),"\n")
    colnames(data4master.dF) <- c("qchr","qstart","qend","qstrand","qlen","qchrtag","hchr","hstart","hend","hstrand","hlen","hchrtag","alignlen")
    cat("Loading sequences...\n")
    fa.V <- read.table(in.fasta.file,header = FALSE,as.is = TRUE,sep = "\t")[,1]
    seq.L <- list()
    for (row in fa.V) {
        if(regexpr(">",row)!=-1){
            faheader <- gsub(">","",row)
        } else {
            seq.L[[faheader]] <- paste(seq.L[[faheader]],row,sep = "")
        }
    }
    ## cat(nchar(seq.L[['IDBA_3']]),"\n")
    ## The following procedure is used to get reverse-complement of all contigs which are on the reverse strand based top-strandedness of the first entry of the blast.file 
    allseq <- ""
    reversed <- FALSE # variable to know strand of previous row
    reversing <- FALSE # variable to know strand of actual row
    for (x in c(1:dim(data4master.dF)[1])){
        row <- data4master.dF[x,]
        ## DEBUG LINE
        ## cat(x,"\t",row$qchr,"\t",row$qlen,"\t",row$alignlen,"\t",row$qchrtag,"\t")
        ## Strandedness for the actual and next contig
        if(row$qstrand==1 & row$hstrand==1 & !reversed){
##            cat("if 1\n")
            reversing <- FALSE
            ## reversed <- FALSE
        } else if(row$qstrand==1 & row$hstrand==1 & reversed){
##            cat("if 2\n")
            reversing <- TRUE
            ## reversed <- TRUE
        } else if (row$qstrand==1 & row$hstrand==-1 & !reversed){
##            cat("if 3\n")
            reversing <- FALSE
            reversed <- TRUE
        } else if (row$qstrand==1 & row$hstrand==-1 & reversed){
##            cat("if 4\n")
            reversing <- TRUE
            reversed <- FALSE
        }
        ## cat(row$qchrtag,"\t",reversed,"\t",reversing,"\n")
        ## Which part of the actual contig needs to be taken
        if(row$qchrtag=="s") {
            subseq <- substr(seq.L[[row$qchr]],row$qend+1,row$qlen)
        } else if (row$qchrtag=="e") {
            subseq <- substr(seq.L[[row$qchr]],1,row$qstart-1)
        }
        if(reversing) {
            subseq <- strReverse(convertToComplement(subseq))
            ## cat(nchar(subseq),"\n")
        }
        ## Concatenate the subsequence to the master sequence
        allseq <- paste(allseq,subseq,sep = "")
    }
    allseq.V <- c(paste(">",fasta.header,sep = ""))
    for (factor in c(0:floor(nchar(allseq)/50))) {
        sub.start <- factor * 50 + 1
        sub.end <- factor * 50 + 50
        allseq.V <- c(allseq.V,substr(allseq,sub.start,sub.end))
    }
    write.table(allseq.V,out.fasta.file,quote = FALSE,col.names = FALSE,row.names = FALSE,sep = "\t")
    cat("... Finished\n")
} else if (script.mode == "calculateSubcircles") {
    ##    cat("Hello World\n")
    wd <- commandArgs(TRUE)[2]
    if (!dir.exists(wd)) {
        stop(paste("Provided working directory '",wd,"' does not exists and so no fasta files in it. Please check.\n",sep=""))
    } else {
        setwd(wd)
    }
    graph.file <- commandArgs(TRUE)[3]
    for (inputfile in c(graph.file)) {
        if (!file.exists(inputfile)) {stop(paste("Provided input file '",inputfile,"' does not exists. Please check.\n",sep=""))}
    }
    g2 <- read.graph(graph.file,format="gml")
    edge.M <- as_edgelist(g2)
    vertices.L <- as_adj_list(g2)
    g2adj.M <- as_adjacency_matrix(g2)
    lay <- layout_with_fr(g2)
    weights.M <- matrix(rep(0,length(lay[,1])*length(lay[,1])),ncol = length(lay[,1]))

    mates.M <- matrix(c(1:length(lay[,1])),ncol = 2,byrow = TRUE)
    mates.L <- list()
    for (i in c(1:length(mates.M[,1]))) {
        left <- mates.M[i,1]
        right <- mates.M[i,2]
        mates.L[[left]] <- right
        mates.L[[right]] <- left
        weights.M[left,right] <- left
        weights.M[right,left] <- right
    }

    pathing <- setClass(
    ## Set the name for the class
    "pathing",
    ## Define the slots
    slots = c(
        s.vertex = "numeric",
        a.vertex = "numeric",
        l.vertex = "numeric",
        n.vertex = "numeric",
        w.sum = "numeric",
        iteration = "numeric",
        vList = "list",
        v.counts.L = "list",
        n.vertices = "numeric",
        path = "vector",
        worked.L = "list"
    ),
    ## Set the default values for the slots. (optional)
    prototype=list(
        s.vertex = 0,
        a.vertex = 0,
        l.vertex = 0,
        n.vertex = 0,
        w.sum = 0,
        iteration = 0,
        vList = list(),
        v.counts.L = list(),
        n.vertices = 0,
        path = c(),
        worked.L = list()
    ),
    ## Make a function that can test to see if the data is consistent.
    ## This is not called if you have an initialize function defined!
    validity=function(object)
    {
        if((object@x < 0) || (object@y < 0)) {
            return("A negative number for one of the coordinates was given.")
        }
        return(TRUE)
    }
    )

    queue.L <- list()
    range.V <- c(1:dim(weights.M)[1])
    for (i in range.V) {
        p <- pathing()
        p@s.vertex <- i
        p@a.vertex <- i
        p@vList <- vertices.L
        p@v.counts.L <- lapply(range.V,function(x) c(0))
        p@worked.L <- lapply(range.V,function(x) c())
        queue.L[[i]] <- p
    }

    all.results.V <- c()
    path.L <- list()
    obj.L <- list()
    iter.max <- as.integer(commandArgs(TRUE)[5])

    repeat.identifier.string <- commandArgs(TRUE)[4]
    repeat.identifier.V <- strsplit(repeat.identifier.string,",")[[1]]
    repeat.vertices.V <- which(as.integer(gsub("[es]","",names(vertices.L))) %in% repeat.identifier.V)
    
    z <- 1

    cat("Going through all possible pathes within the graph. This can take some seconds to minutes... please wait\n")
    cat(date(),"\n")
    repeat{
##        if(z%%1000==0) cat(z,"\n")
        p <- queue.L[[1]]
        queue.L <- queue.L[-1]
        repeat{
            p@n.vertices <- unique(as.vector(unlist(p@vList[[p@a.vertex]])))
            p@n.vertices <- p@n.vertices[!p@n.vertices %in% p@l.vertex]
            p@n.vertex <- p@n.vertices[1]
            if(length(p@n.vertices)!=1) {
                for (i in c(2:length(p@n.vertices))) {
                    p.copy <- p
                    p.copy@n.vertex <- p.copy@n.vertices[i]
                    if(p.copy@l.vertex!=mates.L[[p.copy@n.vertex]]) {
                        add.on <- 2^(weights.M[p.copy@a.vertex,p.copy@n.vertex]+dim(weights.M)[1]*p.copy@v.counts.L[[p.copy@n.vertex]])
                        if(weights.M[p.copy@a.vertex,p.copy@n.vertex]!=0) {
                            p.copy@w.sum <- p.copy@w.sum + add.on
                        }
                    }
                    p.copy@path <- c(p.copy@path,p.copy@n.vertex)
                    if(p.copy@l.vertex!=mates.L[[p.copy@a.vertex]] & p.copy@a.vertex!=mates.L[[p.copy@n.vertex]]) {
                        break
                    }
                    p.copy@l.vertex <- p.copy@a.vertex
                    p.copy@a.vertex <- p.copy@n.vertex
                    p.copy@v.counts.L[[p.copy@a.vertex]] <- p.copy@v.counts.L[[p.copy@a.vertex]] + 1
                    p.copy@worked.L[[p.copy@l.vertex]][length(p.copy@worked.L[[p.copy@l.vertex]])+1] <- p.copy@a.vertex
                    p.copy@worked.L[[p.copy@a.vertex]][length(p.copy@worked.L[[p.copy@a.vertex]])+1] <- p.copy@l.vertex
                    queue.L[[length(queue.L)+1]] <- p.copy
                }
            }
            if(p@l.vertex!=mates.L[[p@n.vertex]]) {
                add.on <- 2^(weights.M[p@a.vertex,p@n.vertex]+dim(weights.M)[1]*p@v.counts.L[[p@n.vertex]])
                if(weights.M[p@a.vertex,p@n.vertex]!=0) p@w.sum <- p@w.sum + add.on
            }
            p@path <- c(p@path,p@n.vertex)
            if(p@l.vertex!=mates.L[[p@a.vertex]] & p@a.vertex!=mates.L[[p@n.vertex]]) {
                break
            }
            p@l.vertex <- p@a.vertex
            p@a.vertex <- p@n.vertex
            p@v.counts.L[[p@a.vertex]] <- p@v.counts.L[[p@a.vertex]] + 1
            p@worked.L[[p@l.vertex]][length(p@worked.L[[p@l.vertex]])+1] <- p@a.vertex
            p@worked.L[[p@a.vertex]][length(p@worked.L[[p@a.vertex]])+1] <- p@l.vertex
            if(p@v.counts.L[[p@a.vertex]]>iter.max) break
            enriched.vertices.V <- c(1:dim(weights.M)[1])[tabulate(p@path,nbins = dim(weights.M)[1])>=iter.max]
            uniq.path.V <- unique(p@path)
            check.length.V <- sapply(uniq.path.V,function(x) length(unique(p@worked.L[[x]])))
            if(p@n.vertex==p@s.vertex & sum(p@vList[[p@s.vertex]] %in% p@path)>1 & sum(check.length.V[!uniq.path.V %in% repeat.vertices.V]==1)==0){
                ## cat("=================================================================\n")
                ## cat(p@s.vertex,"\t",p@w.sum,"\t",length(queue.L),"\t",p@path,"\n")
                path.L[[length(path.L)+1]] <- p@path
                obj.L[[length(path.L)+1]] <- p
                all.results.V <- c(all.results.V,p@w.sum)
                break
            }
        }
        z <- z + 1
        if(length(queue.L)==0)break
    }
    cat(date(),"\n")
    matched.V <- match(all.results.V,all.results.V/2,nomatch = 0)

    path.bool.V <- rep(FALSE,length(path.L))
    permutations.L <- list()
    for (j in c(1:length(path.L))) {
        path2check.V <- path.L[[j]]
        id2check <- paste(path2check.V,collapse = "_")
        if(is.null(permutations.L[[id2check]])) {
            path.bool.V[j] <- TRUE
            for (i in c(1:length(path2check.V))) {
                if(i==1) permut.V <- c(1:length(path2check.V))
                if(i>1) permut.V <- c(i:length(path2check.V),c(1:(i-1)))
                permut.id <- paste(path2check.V[permut.V],collapse = "_")
                permutations.L[[permut.id]] <- 1
                permut.id <- paste(rev(path2check.V[permut.V]),collapse = "_")
                permutations.L[[permut.id]] <- 1
            }
        }
    }

    real.path.indeces.V <- which(path.bool.V)
    complete.graphs.bool.V <- rep(FALSE,length(path.L))
    smallest.graphs.bool.V <- rep(FALSE,length(path.L))
    intermediate.graphs.bool.V <- rep(FALSE,length(path.L))
    contig.twice.graphs.bool.V <- rep(FALSE,length(path.L))

    sum(contig.twice.graphs.bool.V)

    num.vertices <- dim(weights.M)[1]
    num.repeats <- length(repeat.vertices.V)
    i <- 5

    sum.M <- matrix(rep(0,length(real.path.indeces.V)*6),ncol = 6,byrow = TRUE)

    for (i in c(1:length(real.path.indeces.V))) {
        index <- real.path.indeces.V[i]
        ## cat(index,"\n")
        rep.zero <- sum(tabulate(path.L[[index]],nbins = num.vertices)[repeat.vertices.V]==0)
        rep.once <- sum(tabulate(path.L[[index]],nbins = num.vertices)[repeat.vertices.V]==1)
        rep.twice <- sum(tabulate(path.L[[index]],nbins = num.vertices)[repeat.vertices.V]==2)
        contig.zero <- sum(tabulate(path.L[[index]],nbins = num.vertices)[-repeat.vertices.V]==0)
        contig.once <- sum(tabulate(path.L[[index]],nbins = num.vertices)[-repeat.vertices.V]==1)
        contig.twice <- sum(tabulate(path.L[[index]],nbins = num.vertices)[-repeat.vertices.V]==2)

        sum.M[i,]  <- c(rep.zero,rep.once,rep.twice,contig.zero,contig.once,contig.twice)
        
        non.repeat.twice.used.sum <- sum(tabulate(path.L[[index]],nbins = num.vertices)[-repeat.vertices.V]==2)
        non.repeat.usage.sum <- sum(tabulate(path.L[[index]],nbins = num.vertices)[-repeat.vertices.V]!=1)
        repeat.usage.sum <- sum(tabulate(path.L[[index]],nbins = num.vertices)[repeat.vertices.V]!=2)
        if(contig.twice!=0) contig.twice.graphs.bool.V[index] <-  TRUE
        else if(non.repeat.twice.used.sum!=0 & repeat.usage.sum!=num.repeats & repeat.usage.sum!=0) intermediate.graphs.bool.V[index] <- TRUE
        else if(non.repeat.usage.sum==0 & repeat.usage.sum==0) complete.graphs.bool.V[index] <- TRUE
        else if(non.repeat.usage.sum!=0 & repeat.usage.sum==num.repeats) smallest.graphs.bool.V[index] <- TRUE
    }
    allother.graphs.bool.V <- !complete.graphs.bool.V & !smallest.graphs.bool.V & !intermediate.graphs.bool.V & !contig.twice.graphs.bool.V & path.bool.V

    sum.bool.M <- sum.M
    sum.bool.M[sum.bool.M!=0] <- 1
    bool.patterns.M <- unique(sum.bool.M)
    cbind(bool.patterns.M,apply(bool.patterns.M,1,function(p) sum(apply(sum.bool.M,1,function(x) sum(x==p))==6)))

    ## repeat.usage.sum:   number of repeats used twice
    ## non.repeat.usage.sum: number of normal contigs used more than once
    ## non.repeat.twice.used.sum: number of normal contigs that were used twice

    path.indeces.V <- c(
        which(complete.graphs.bool.V),
        which(smallest.graphs.bool.V),
        which(intermediate.graphs.bool.V),
        which(allother.graphs.bool.V))

    pdf.out <- commandArgs(TRUE)[6]
    pdf(pdf.out,width = 10,height = 10)
    for (j in path.indeces.V) {
        new.M <- matrix(rep(0,num.vertices*num.vertices),ncol = num.vertices)
        path4plot.V <- path.L[[j]]
        for (i in c(1:(length(path4plot.V)-1))) {
            l <- path4plot.V[i]
            r <- path4plot.V[i+1]
            new.M[l,r] <- 1
        }
        ## Last connection between first and last entry in path4plot
        new.M[path4plot.V[length(path4plot.V)],path4plot.V[1]] <- 1
        rownames(new.M) <- names(vertices.L)
        colnames(new.M) <- names(vertices.L)
        g3 <- graph.adjacency(new.M,mode="directed")
        vertex.colors.V <- rep("white",dim(new.M)[1])
        vertex.colors.V[path4plot.V]  <- "grey"
        plot(g3,layout=lay,main = "",edge.width=3,vertex.size=0,vertex.color=vertex.colors.V,vertex.frame.color=vertex.colors.V)
    }
    dev.off()
    cat("Finished and save")
#################################################
#### WORK IN PROGRESS
#################################################
## } else if (script.mode == "getAllPairCounts") {
##     cat("Hello World2\n")
##     wd <- commandArgs(TRUE)[2]
##     if (!dir.exists(wd)) {
##         stop(paste("Provided working directory '",wd,"' does not exists and so no fasta files in it. Please check.\n",sep=""))
##     } else {
##         setwd(wd)
##     }
##     sagbac.prefix <- commandArgs(TRUE)[3]
##     pairCounts.file <- paste(sagbac.prefix,".bam.mates.MappedOnDiffContig.pairCounts",sep = "")
##     contigsInGraph.file <- commandArgs(TRUE)[4]
##     assembly.prefix <- contigsingraph.file <- commandArgs(TRUE)[5]
    
##     for (inputfile in c(pairCounts.file,contigsInGraph.file)) {
##         if (!file.exists(inputfile)) {stop(paste("Provided input file '",inputfile,"' does not exists. Please check.\n",sep=""))}
##     }   
##     pairCounts.dF <- read.table(pairCounts.file,header = FALSE,as.is = TRUE,sep = "\t")
##     colnames(pairCounts.dF) <- c("qchrnum","hchrnum","count")
##     contigs.V <- gsub(assembly.prefix,"",read.table(contigsInGraph.file,header = FALSE,as.is = TRUE,sep = "\t")[,1])
##     contigs.V
## #### New mode generating a excel sheet with all Pair counts
##     ## ~/ngsresults/code/R/adjMatrix_on_spanningCounts.R
##     ## ~/Nextcloud/code/R/adjMatrix_on_spanningCounts.R
## } else if (script.mode == "getOtherPairCounts") {
##     wd <- commandArgs(TRUE)[2]
##     if (!dir.exists(wd)) {
##         stop(paste("Provided working directory '",wd,"' does not exists and so no fasta files in it. Please check.\n",sep=""))
##     } else {
##         setwd(wd)
##     }
##     sagbac.prefix <- commandArgs(TRUE)[3]
##     pairCounts.file <- paste(sagbac.prefix,".bam.mates.MappedOnDiffContig.pairCounts",sep = "")
##     for (inputfile in c(pairCounts.file)) {
##         if (!file.exists(inputfile)) {stop(paste("Provided input file '",inputfile,"' does not exists. Please check.\n",sep=""))}
##     }   
##     pairCounts.dF <- read.table(pairCounts.file,header = FALSE,as.is = TRUE,sep = "\t")
##     colnames(pairCounts.dF) <- c("qchrnum","hchrnum","count")
##     input.string <- commandArgs(TRUE)[4]
## ##    input.string <- "2,9,762,156:795;0,3,5,12:518;9,16,5,789:121"
##     splitted.forks.V <- strsplit(input.string,";")[[1]]
##     for (i in c(1:length(splitted.forks.V))) {
##         splitted.fork <- splitted.forks.V[i]
##         combis.V <- strsplit(splitted.fork[1],":")[[1]]
##         ucontigs.V <- as.integer(strsplit(combis.V[1],",")[[1]])
##         fork.V <- as.integer(strsplit(combis.V[2],",")[[1]])
##         cat("New combi\n")
##         for (x in ucontigs.V) {
##             for (y in fork.V) {
##                 if(x > y) {
##                     right <- x
##                     left <- y
##                 } else {
##                     right <- y
##                     left <- x
##                 }
##                 if(length(which(pairCounts.dF$qchrnum==left & pairCounts.dF$hchrnum==right))!=0) {
##                     cat(paste(pairCounts.dF[which(pairCounts.dF$qchrnum==left & pairCounts.dF$hchrnum==right),],collapse = "_"),"\n")
##                 } else {
##                     cat(paste(left,right,"0",collapse = "_"),"\n")
##                 }
##             }
##         }
##     }    
## }

